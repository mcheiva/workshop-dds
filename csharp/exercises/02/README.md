# Exercise 2: Make Your Own Publisher

In this exercise we create a very simple Publisher with a DataWriter that connects and publishes on a single topic based on the initial IDL provided in the `idls` folder.
Open the Publisher project under `Solution/Publisher` and let's include the using statements required for the API. These pull in the native Fast DDS components, reduce boilerplate, and manage internal DDS entity lifecycles.

```csharp
using Eiva.DDSBus;
using Eiva.DDSBus.Core;
```

Next, include the topic types autogenerated by fastddsgen; it provides serialization methods and the underlying type needed to set up the DataWriter.

```csharp
using IDL;
```

Next define a listener. Here we create `MyExampleListener` inheriting from the API abstract class `DataWriterListener`. This class holds the logic for internal writer events. For this example we are primarily interested in: (a) successful matches with a DataReader and (b) attempted connections with incompatible QoS; therefore we override `OnPublicationMatched` and `OnOfferedIncompatibleQos`. Inspect the available fields in the `status` and `info` objects and experiment with overriding additional callbacks if desired.

```csharp
// ----------- Example Listener Class ----------- //
class MyExampleListener : Eiva.DDSBus.Core.DataWriterListener
{
    public override void OnPublicationMatched(FastDDS.PublicationMatchedStatus info)
    {
        Console.WriteLine(
            $"[Publisher] Match status changed: {info.current_count} subscribers(s) connected." +
            $" {info.total_count} total connection(s)");
    }

    public override void OnOfferedIncompatibleQos(IncompatibleQosStatus status)
    {
        Console.WriteLine(
            $"[Subscriber] Incompatible QoS requested. Total count: {status.total_count} " +
            $", last violated policy ID: {status.last_policy_id}");
    }
}
```

Set up the DDS entities inside `main` — this takes only a few lines. To fully initialize:
1. Select a suitable domain. DDS allows domains 0–255 (0 is default). All Participants must share the same domain or they will not connect.
2. Provide the `Topic` class with the `TopicType` version of your IDL so serialization methods are registered with the Participant. This looks slightly different from the C++ variant, as reflection helps with type deduction ;)
3. Choose a suitable topic name. It must match between DataWriter and DataReader for discovery. Prefer structured naming (e.g. `MCH/MyAwesomeTopic`).
4. Instantiate the listener and pass its reference to the DataWriter so overridden callbacks are invoked on events.

```csharp
// ----------- SETUP ----------- //

Participant participant = new Participant(<DomainID>);
Publisher publisher = participant.CreatePublisher();
Topic<Awesome> topic = participant.CreateTopic<Awesome>(<SomeTopicName>);

MyExampleListener listener = new MyExampleListener();
IDataWriter<Awesome> dataWriter = publisher.CreateDataWriter(topic, listener: listener);
```

In production code you might instantiate the DataWriter inside the `MyExampleListener` constructor so logging and lifecycle concerns remain co-located. In that case pass `this` instead of `listener`. For now we use default settings for Participant, Publisher, and DataWriter; later exercises introduce more fine‑tuned QoS.

At this point we have a working setup attempting to connect on the specified domain with the chosen topic type. Next, set up the publishing code. The simplest case instantiates `Awesome` and sets member fields.

```csharp
// ----------- Construct Sample ----------- //
Awesome sample = new Awesome();
sample.id(1337);
```

For publishing you could implement a loop, custom logic, or simply block the terminal until a keypress signals the sample should be sent. We'll do the simple version first. Publishing is a templated `publish` call on the DataWriter, providing static type checking.

```csharp
// ----------- Publish Sample ----------- //
Console.WriteLine("Press any key to send a sample...");
Console.ReadKey();

dataWriter.Publish(sample);
Console.WriteLine($"Published sample with id = { sample.id() }"); 
```

Lastly, keep the publisher alive until the user closes the application; this becomes important in later exercises.
```cpp
// ----------- Keep alive ----------- //
Console.WriteLine("Press any key to close publisher....");
Console.ReadKey();
```

In this example a listener was used. You could omit it, but then the DataWriter would have no visibility into system events that are typically important for logging.

Start the publisher and verify that everything compiles. When prompted about the windows firewall click "show more" and ensure all 3 boxes are ticked, then hit okay and login with your secondary eiva account.