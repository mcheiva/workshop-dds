# Exercise 2: Make your own Publisher

In this exercise we will create a very simple Publisher with a datawriter that connects and publishes on a single topic based on the initial IDL that I have provided in the idls folder. 
Open up the Publisher project, under Solution/Publisher and lets include some of the headers for the API that will be required for this to run. These files internally include all the native fastdds headers and helps reduce boilerplate code and deals with internal lifecycle management of the dds entities.

```cpp
// Include DDSBus Fast DDS headers
#include <ddsbus/fastdds/Participant.hpp>
#include <ddsbus/fastdds/Publisher.hpp>
#include <ddsbus/fastdds/Topic.hpp>
#include <ddsbus/fastdds/DataWriter.hpp>
```

Next, we also need to include a topic type. It is generally only required to load the `<IDL>PubSubTypes.hpp` headerfile that was autogenerated by fastddsgen as it includes both the serialization methods and includes the underlying type we wish to publish which is all we need to setup the DataWriter

```cpp
// Include PubType header of your generated type
#include <idls/AwesomePubSubTypes.hpp>
```

Next we need to define a listener, in this case we define our own class `MyExampleListener` that inherits from the api abstract class `DataWriterListener`. This class will hold the logic for what happens when certain events are triggered internally on the writer. In the case of this example in particular, we are only truely interested in knowing if we are successfully matched with a DataReader and if someone tried to connect but had incompatible qos settings, therefore we override the `on_publication_matched` and `on_offered_incompatible_qos`. I urge you to inspect what properties are available to you in the `status` variables and to play around with overridding more callbacks (if you want).

```cpp
// Create your own DataWriterListener by inheriting from ddsbus::core::DataWriterListener
class MyExampleListener : public ddsbus::core::DataWriterListener
{
public:
    MyExampleListener() = default;
private:
    void on_publication_matched(const eprosima::fastdds::dds::PublicationMatchedStatus &status) override
    {
        std::cout << "[Publisher] Match status changed: "
        << status.current_count << " subscriber(s) connected. "
        << status.total_count << " total connection(s)\n";
    }
    void on_offered_incompatible_qos(const eprosima::fastdds::dds::OfferedIncompatibleQosStatus &status) override
    {
        std::cout << "[Publisher] Incompatible QoS offered. Total count: "
        << status.total_count << ", last violated policy ID: " << status.last_policy_id << '\n';
    }
};
```

Next we need to setup the actual DDS entites inside the main function, this can all be done in very few lines of code. To fully setup the service we need to figure out
1. A suitable domain for us to connect to, DDS allows you to connect between 0-255, 0 being the default. Please recall that if Participants are not on the same domain, they will not connect! so whatever value is chosen for the domain_id, the same should be chosen for the DataReader service!
2. We need to provide the `Topic` class with the `PubSubType` version of our desired IDL. This is to allow us to register the serialization methods on the Participant such that it knows how to serialize the published data samples.
3. Choose a suitable `Topic Name`, this is very essential as both DataReader and DataWriter needs to share the same topic type and topic name in order for connection to happen. In general, the topic name should be unique, so choose something ordered like e.g.: `MCH/MyAwesomeTopic`, the name can in theory be anything, but try to give it meaning.  
4. Instantiate the Listener we defined above and parse a pointer reference to the `DataWriter`, this will allow the DataWriter to invoke your overriden callbacks whenever the events occur in the system.

```cpp
// Perform DDS Setup
ddsbus::fastdds::Participant participant(<domain_id>);
ddsbus::fastdds::Publisher publisher = participant.create_publisher();
ddsbus::fastdds::Topic<AwesomePubSubType> topic = participant.create_topic<AwesomePubSubType>(<SomeTopicName>);

MyExampleListener listener;
ddsbus::fastdds::DataWriter<AwesomePubSubType> dataWriter = publisher.create_datawriter(topic, &listener);
```

In actual production code you might want to instantiate the DataWriter directly inside the constructor of `MyExampleListener`, such that logging information etc lives together with the datawriter itself and will simplify lifecycle management. In this case you would just parse `this` instead of `&listener`. Furthermore, in this example we are using all the default settings for both the Participant, Publisher, and DataWriter. In later exercises we will expand on the setup with more fine-tuned settings.

At this point we have a working setup that attempts to connect on the specified domain with our chosen topic type. Now we need to setup the publishing code itself. Doing so is very trivial and could be done in many ways, but the simplest case involves instantiating our topic type `Awesome` and setting the member variables to some values

```cpp
// Create data sample to publish
Awesome sample;
sample.id(1337);
```

Now for the actual publishing of the sample you could implement a loop, some fancy logic or just block the terminal until a user press is signalled for the sample to be published. Lets do the simple version first. Publising the sample is as simple as calling `publish` on DataWriter we created previously. This is a templated method which allows static type checking meaning that you have to provide the correct type to the call.

```cpp
// Publish data sample
std::cout << "Press any key to send a sample..." << std::endl;
std::cin.ignore();

dataWriter.publish(sample);
std::cout << "Published sample with id = " << sample.id() << std::endl;
```

Lastly, we let the publisher live until the user decides to fully close the application, this will become important for later exercises.
```cpp
// Block to keep the publisher alive
std::cout << "Press any key to stop the publisher..." << std::endl;
std::cin.ignore();
```

In this example a listener was used, however you could have omitted the listener entirely, however in that case you would have a DataWriter with no information about system events which typically are important for logging purposes.