# Exercise 2: Make Your Own Publisher

In this exercise we create a very simple Publisher with a DataWriter that connects and publishes on a single topic based on the initial IDL provided in the `idls` folder.
Open the Publisher project under `Solution/Publisher` and let's include the headers required for the API. These headers pull in the native Fast DDS components, reduce boilerplate, and manage internal DDS entity lifecycles.

```cpp
// Include DDSBus Fast DDS headers
#include <ddsbus/fastdds/Participant.hpp>
#include <ddsbus/fastdds/Publisher.hpp>
#include <ddsbus/fastdds/Topic.hpp>
#include <ddsbus/fastdds/DataWriter.hpp>
```

Next, include the topic type. It is generally sufficient to load the `<IDL>PubSubTypes.hpp` header file autogenerated by fastddsgen; it provides serialization methods and the underlying type needed to set up the DataWriter.

```cpp
// Include PubType header of your generated type
#include <idls/AwesomePubSubTypes.hpp>
```

Next define a listener. Here we create `MyExampleListener` inheriting from the API abstract class `DataWriterListener`. This class holds the logic for internal writer events. For this example we are primarily interested in: (a) successful matches with a DataReader and (b) attempted connections with incompatible QoS; therefore we override `on_publication_matched` and `on_offered_incompatible_qos`. Inspect the available fields in the `status` objects and experiment with overriding additional callbacks if desired.

```cpp
// Create your own DataWriterListener by inheriting from ddsbus::core::DataWriterListener
class MyExampleListener : public ddsbus::core::DataWriterListener
{
public:
    MyExampleListener() = default;
private:
    void on_publication_matched(const eprosima::fastdds::dds::PublicationMatchedStatus &status) override
    {
        std::cout << "[Publisher] Match status changed: "
        << status.current_count << " subscriber(s) connected. "
        << status.total_count << " total connection(s)\n";
    }
    void on_offered_incompatible_qos(const eprosima::fastdds::dds::OfferedIncompatibleQosStatus &status) override
    {
        std::cout << "[Publisher] Incompatible QoS offered. Total count: "
        << status.total_count << ", last violated policy ID: " << status.last_policy_id << '\n';
    }
};
```

Set up the DDS entities inside `main` — this takes only a few lines. To fully initialize:
1. Select a suitable domain. DDS allows domains 0–255 (0 is default). All Participants must share the same domain or they will not connect.
2. Provide the `Topic` class with the `PubSubType` version of your IDL so serialization methods are registered with the Participant.
3. Choose a suitable topic name. It must match between DataWriter and DataReader for discovery. Prefer structured naming (e.g. `MCH/MyAwesomeTopic`).
4. Instantiate the listener and pass its pointer to the DataWriter so overridden callbacks are invoked on events.

```cpp
// Perform DDS Setup
ddsbus::fastdds::Participant participant(<domain_id>);
ddsbus::fastdds::Publisher publisher = participant.create_publisher();
ddsbus::fastdds::Topic<AwesomePubSubType> topic = participant.create_topic<AwesomePubSubType>(<SomeTopicName>);

MyExampleListener listener;
ddsbus::fastdds::DataWriter<AwesomePubSubType> dataWriter = publisher.create_datawriter(topic, &listener);
```

In production code you might instantiate the DataWriter inside the `MyExampleListener` constructor so logging and lifecycle concerns remain co-located. In that case pass `this` instead of `&listener`. For now we use default settings for Participant, Publisher, and DataWriter; later exercises introduce more fine‑tuned QoS.

At this point we have a working setup attempting to connect on the specified domain with the chosen topic type. Next, set up the publishing code. The simplest case instantiates `Awesome` and sets member fields.

```cpp
// Create data sample to publish
Awesome sample;
sample.id(1337);
```

For publishing you could implement a loop, custom logic, or simply block the terminal until a keypress signals the sample should be sent. We'll do the simple version first. Publishing is a templated `publish` call on the DataWriter, providing static type checking.

```cpp
// Publish data sample
std::cout << "Press any key to send a sample..." << std::endl;
std::cin.ignore();

dataWriter.publish(sample);
std::cout << "Published sample with id = " << sample.id() << std::endl;
```

Lastly, keep the publisher alive until the user closes the application; this becomes important in later exercises.
```cpp
// Block to keep the publisher alive
std::cout << "Press any key to stop the publisher..." << std::endl;
std::cin.ignore();
```

In this example a listener was used. You could omit it, but then the DataWriter would have no visibility into system events that are typically important for logging.